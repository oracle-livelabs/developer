# Coding basics for this lab

## Introduction

At Seer Holdings, developers are building a next-generation approval system that needs to combine enterprise-grade data governance with modern AI capabilities. But before GenAI or vector search can be applied, one thing must be true:

ðŸ‘‰ The data must be in the right shape â€” accessible, trustworthy, and programmable.

In this lab, youâ€™ll act as a developer on the Seer Holdings data team. Your job is to build the foundational logic that powers the applicationâ€™s intelligence layer. That means:

- Creating and querying relational tables that represent real customer data using Python
- Project that data into **JSON documents** using **JSON Duality Views**
- Using **MongoDB-style syntax** via Oracleâ€™s Mongo API to interact with the same data â€” without needing to duplicate or move it to another system

These capabilities help you write less glue code, eliminate data movement/sync, and stay focused on the real task: powering intelligent workflows and providing value.

> ðŸ’¡ Everything you implement here becomes the data foundation for Retrieval-Augmented Generation (RAG), AI Vector Search, and AI agents in upcoming labs.

Estimated Time: 30 minutes

### Objectives

- Connect to Oracle AI Database using Python  
- Create and query relational data  
- Use JSON Duality Views to work with relational tables as JSON  
- Query and update the same data using MongoDB-style syntax

### Prerequisites

This lab assumes you have:

- An Oracle account with LiveLabs access  
- Completion of **Lab 1: Connect to the Development Environment**  
- Basic familiarity with Python and SQL


## Task 1: Create a new Jupyter Notebook

All of the coding examples will be executed in a new Jupyter Notebook.

1. In **JupyterLab**, click the blue **+** to open the Launcher  

    ![Open Launcher](./images/launcher.png " ")

2. Start a new **Python (ipykernel)** notebook

    ![Open Jupyter Notebook](./images/open-new-notebook.png " ")

## Task 2: Connect to the database using Python

In this first task, you will connect to an Oracle AI Database instance using Oracle's Python driver, `oracledb`. `oracledb` is available in PyPi (`pip install oracledb`) and in its latest version, supports all of the advanced features of the Oracle Database, including JSON, VECTOR, and more.

1. In the newly created Jupyter Notebook, copy and paste the following code block into an empty cell. This code block imports the `oracledb` Python driver and other libraries that help us to securely read credentials from the environment variables.

    ```python
    <copy>
    import os
    from dotenv import load_dotenv
    import oracledb

    load_dotenv()

    username = os.getenv("USERNAME")
    password = os.getenv("DBPASSWORD")
    dsn = os.getenv("DBCONNECTION")

    try:
        connection = oracledb.connect(user=username, password=password, dsn=dsn)
        print("Connection successful!")
    except Exception as e:
        print(f"Connection failed: {e}")

    cursor = connection.cursor()
    </copy>
    ```

2. Execute the cell by entering **shift + enter** or clicking on the play button.

3. You should see a message that says "Connection successful!" in your notebook. If you do not, check the credentials and try again. 

    ![connect](./images/connect.png " ")

>**Note:** The last line, `cursor = connection.cursor()`, creates a cursor object from the established Oracle database connection. A cursor acts as a control structure that enables the execution of SQL queries and retrieval of results from the database. It is essential for sending SQL commands, fetching data, and iterating through query results. We will be using the cursor object in later steps of this lab. The object persists in the notebook session, so you can use it in subsequent cells without re-establishing the connection.

## Task 3: Create tables and insert data

Now, that we have established a connection, we can start creating our tables and inserting some sample data. We will create two sample tables (`orders` and `customers`) in our database. We will also insert some sample data into these tables.

1. In a new cell, enter the following code to create the `orders_demo` table and insert some sample data:

    ```python
    <copy>
    # Create a table to hold orders and insert some data
    try:
        with connection.cursor() as cursor:
            cursor.execute("""
                drop table if exists orders_demo
                """)
            cursor.execute("""
                create table if not exists orders_demo
                    (id number generated by default on null as identity,
                    product_id number,
                    order_date timestamp,
                    customer_id number,
                    total_value number(6,2),
                    order_shipped boolean,
                    warranty interval year to month)""")
            cursor.execute("""
                insert into orders_demo (product_id, order_date, customer_id, total_value, order_shipped, warranty)
                values
                (12, systimestamp, 100001, 10.23, true, interval '2-0' year to month),
                (234, systimestamp, 223223, 1200.00, false, interval '1-6' year to month),
                (57, systimestamp, 238121, 110.1, True, interval '5-0' year to month),
                (2, systimestamp, 78993, 20.50, null, interval '0-6' year to month)
            """)
            connection.commit()
            print("Success!")
    except oracledb.DatabaseError as e:
        print(f"Error: {e}")
        </copy>
    ```

2. Let's now create some code that allows us to query our table.

    ```python
    <copy>
    def query_orders():
        with connection.cursor() as cursor:
            cursor.execute("select * from orders_demo")
            rows = cursor.fetchall()
        for row in rows:
            print(row)

    query_orders()
    </copy>
   ```

>**Note:** We are creating a function called `query_orders()` that will allow us to query our table. We can use the same function in one of the following tasks

3. Run your code (**shift+enter**) and see what happens. You should get a list of all the orders in our table.

    ![query orders](./images/query-orders.png " ")

4. Next, let's add another table `customers_demo` with some sample data. Copy & paste the following code in a **new cell** and run it.

    ```python
    <copy>
    # Create a table to hold customers and insert some data
    try:
        with connection.cursor() as cursor:
            cursor.execute("""
                drop table if exists customers_demo
                """)
            cursor.execute("""
                create table if not exists customers_demo (
                    id             NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
                    first_name     VARCHAR2(100),
                    last_name      VARCHAR2(100),
                    email          VARCHAR2(320),
                    address        VARCHAR2(80),
                    phone_number   VARCHAR2(20))
                """)
            cursor.execute("""
                insert into customers_demo (id, first_name, last_name, email, address, phone_number)
                values
                (100001, 'Dan', 'Thompson', 'dt7889@gmail.com', '10 smith street', '34454-1667'),
                (223223, 'John', 'Smith', 'jsmith@hotmail.com', 'the grove', '28902'),
                (238121, 'Janet', 'White', 'jw123@gmail.com', 'apartment 256, 120 east street', '18092-7980'),
                (78993, 'Sue', 'Gray', 'sue_gray@testmail.com', '2345 main street', '34454')
                """)
            connection.commit()
            print("Success!")
    except oracledb.DatabaseError as e:
        print(f"Error: {e}")
    </copy>
    ```

5. As before, we want to create a function that allows us to query our new table. We will use a function called `query_customer`. Copy & paste the following code into a **new cell** and execute it. Remember to use SHIFT + ENTER keys.

    ```python
    <copy>
    def query_customers():
        with connection.cursor() as cursor:
            cursor.execute("select * from customers_demo")
            rows = cursor.fetchall()
            for row in rows:
                print(row)
    query_customers()
    </copy>
    ```

    ![query customers](./images/task3.png " ")

### **Task Summary**

Nice job. You successfully created two new tables with sample data using Python and Oracle Database.  

You also created a function that allows you to query your new table which we'll use in some of the following tasks

## Task 4: Create a JSON Duality View 

Next, let's explore how we can use a **JSON Duality View** to query our new table. A JSON Duality View allows us to interact with data as JSON objects, i.e., data is stored as documents. Unlike a regular view, we can also update data in a JSON Duality View. Any updates will be reflected in our original relational tables. We will create a JSON Duality View using our newly created tables `customers_demo` and `orders_demo`. We are joining these two tables as we need the customer orders with the customer data. If this was two collections in a document database, this would be two seperate queries to the database and word in your app, or it'd mean duplicate data, depending on how you modeled your data in that database.

1. Before we create the **JSON Duality View**, we need to add some **constraints** to our new tables. Copy & paste the following code into a **new cell** and run it.

    ```python
    <copy>
    # Create required constraints to prepare JSON Duality View
    try:
        with connection.cursor() as cursor:
            cursor.execute("""
                alter table customers_demo add (constraint customers_pk primary key (id))
                """)
            cursor.execute("""
            alter table orders_demo add (constraint orders_pk primary key (id))
                """)
            cursor.execute("""
            alter table orders_demo add (constraint orders_fk FOREIGN KEY (customer_id) REFERENCES customers_demo (id))
                """)
            connection.commit()
            print("All constraints created.")
    except oracledb.DatabaseError as e:
            print(f"Error: {e}")
    </copy>
    ```

    ![constraints](./images/constraints.png " ")

2. Now we can create our **JSON Duality View**. Copy the following code into a new cell and run it.

    ```python
    <copy>
    # Create JSON Duality View
    try:
        with connection.cursor() as cursor:
            cursor.execute("""
            drop view if exists customers_dv
            """)
            cursor.execute("""
                CREATE or REPLACE JSON RELATIONAL DUALITY VIEW customers_dv AS
                    customers_demo @insert @update @delete
                    {_id      : id
                    FirstName       : first_name
                    LastName        : last_name
                    Email           : email
                    Address         : address
                    Phone    : phone_number
                    orders : orders_demo @insert @update @delete
                    [ {OrderID             : id
                        ProductID           : product_id
                        OrderDate           : order_date
                        TotalValue          : total_value
                        OrderShipped        : order_shipped
                        } ]
                    }
                """)
            connection.commit()
            print("JSON Duality View created")
    except oracledb.DatabaseError as e:
            print(f"Error: {e}")
    </copy>
    ```

    ![dv](./images/dv.png " ")

>ðŸ’¡ **JSON Duality Views** automatically maps relational columns to JSON documents (and vice versa) in the same table, letting you store data in a traditional schema but also access it as if it were a JSON object. So even though youâ€™ve coded a JSON view in Python, you can switch over to standard SQL queries without duplicating data or maintaining extra structures. Super cool! 

3. Let's create a new function that allows us to query our new JSON Duality View. This time however, we will enhance our function to allow using input parameters. Instead of retrieving all rows, we want to write a function that returns only a specific row based on the first name of a customer. Copy the following code into a new cell and run it.

    ```python
    <copy>
    import json

    def query_dv(first_name):
        with connection.cursor() as cursor:
            query = """
                SELECT * FROM customers_dv c
                WHERE JSON_EXISTS(c.data, '$[*]?(@.FirstName == $first_name)' PASSING :first_name AS "first_name")
            """
            cursor.execute(query, {"first_name": first_name})
            rows = cursor.fetchall()
            for row in rows:
                raw_json = row[0]
                try:
                    print(json.dumps(raw_json, default=str, indent=4))
                except Exception as e:
                    print(f"Error formatting JSON: {e}")
                    print(raw_json)

    query_dv("Dan")
    </copy>
    ```

    ![dv](./images/task4-1.png " ")

    You notice that our code has some significant changes. We are now passing a parameter into our query, and we are formatting the output of our query. Let's have a closer look:

    ðŸ”´ **`import json`** - This is a Python module that allows us to work with JSON. Remember: JSON Duality Views present data in document format, i.e., JSON.

    ðŸ”´ **`query_dv(first_name)`** - This is a function that takes in a parameter and returns the result of our query. We are passing in `first_name` as a parameter, which we can use to filter our results.

    ðŸ”´ **`...WHERE JSON_EXISTS...`** - This is an Oracle AI Database function called `JSON_EXISTS`, which allows us to check if a specific key exists in a JSON object. In this case, we are checking if the `first_name` key exists in our JSON document. Essentially, `JSON_EXISTS` function enables us to use SQL syntax to check if a key exists in a JSON object. Remember, unlike rows in a relational table, JSON documents in the same collection don't all have to have the same shape.

    ðŸ”´ **`json.dumps(raw_json, default=str, indent=4)`** - This is a Python function that formats our output. We are passing in the `raw_json` variable as an argument and formatting it with the `default=str` parameter.

    ðŸ”´ **`query_dv("Dan")`** - Here we are calling our query function again, but this time passing in the string `"Dan"` as a parameter. This will return all rows where `first_name` is equal to `"Dan"`. The result is displayed in JSON format, since it's coming from a JSON Duality View.

>**Note:** Notice that our output is a nicely formatted document that now not only includes our customer data but also all orders for that customer.

## Task 5: Connect to the database using pymongo

Next, we will connect to our database and query the data using a the Python driver `pymongo`. That way we can interact with Oracle AI Database using Mongo API which allows us to use the same syntax as MongoDB. We will also learn how to update our database using `pymongo` in a following task.

1. Copy & paste the following code into a new cell and run it.

    ```python
    <copy>
    from pymongo import MongoClient

    def mongo_connect():
        try:
            client = MongoClient(
                os.getenv("MONGODBAPI")
            )
            db = client["admin"]
            print("Connected using MongoAPI!")
            return db
        except Exception as e:
            print(f"Connection failed: {e}")

    mongo_connect()
    </copy>
    ```

    ![dv](./images/mongo-connect.png " ")


## Task 6: Query data using Oracle's Mongo API

Now, that we have established a connection to Oracle AI Database via Mongo API, let's try to query the database using MongoDB syntax. Let's write a function that will help us do this.

1. Copy & paste the following code into a new cell and run it.

    ```python
    <copy>
    def get_mongo(first_name):
        col = mongo_connect().CUSTOMERS_DV
        mongo_data = col.find_one({"FirstName": first_name})
        return mongo_data

    get_mongo("Dan")
    </copy>
    ```

    ![dv](./images/task6.png " ")    

    As you can see, the result matches that of the SQL query (`query_dv()`), though the MongoDB syntax requires significantly less code.

## Task 7: Update data using Oracle's Mongo API

Next, let's update some data in our database using MongoDB syntax. Let's write a function that will help us do this.

1. We want to change the email address of our customer "Dan" to "dant@aol.com". Copy & paste the following code into a **new cell** and run it.

    ```python
    <copy>
    def update_mongo():
        col = mongo_connect().CUSTOMERS_DV
        col.update_one({"FirstName": "Dan"}, {"$set": {"Email": "dant@aol.com"}})
        return

    update_mongo()
    </copy>
    ```

2. Now, let's run our function from task 5 to see if the data was actually updated. Copy the following code into a new cell and run it.

    ```python
    <copy>
    get_mongo("Dan")
    </copy>
    ```

    And indeed, we can see that the email address has been updated.


    ![dv](./images/task7-1.png " ")


3. What if we want to do something more complex, for example updating a nested field? For example, let's say we want to change TotalValue field. Copy the following code into a new cell and run it.

    ```python
    <copy>
    def update_mongo_order():
        col = mongo_connect().CUSTOMERS_DV
        col.update_one(
            {
                "FirstName": "Dan",
                "orders.OrderID": 1.0
            },
            {
                "$set":{"orders.$.TotalValue": 100}
            }
        )
        return
    update_mongo_order()
        </copy>
        ```

4. Let's check what happened by running a query on the JSON Duality view. Copy the following code into a new cell and run it.

    ```python
    <copy>
    get_mongo("Dan")
    </copy>
    ```

    ![mongo query total value](./images/task7-3.png " ")

    You should see that the TotalValue field has been updated from 10.23 to 100.0.
    
## Task 8: Query relational tables to verify updates made through JSON Duality View

The final step in our basic coding tour with Python and the Oracle AI Database is to query the two relational tables we created earlier. We just updated the JSON Duality view, so let's run a query on it to see if the changes were reflected. Remember that we created two functions in the beginning of this lab: `query_customers()` and `query_orders()`. Let's use these functions to get our data from MongoDB and update it with the new email address.

1. First, run the ``query_customers()` function in a new cell

    ```python
    <copy>
    query_customers()
    </copy>
    ```

    ![customer table after update](./images/task8.png " ")

    You can see that also in the relational `customers_demo` table, the email address has been updated.

2. Next, run the `query_orders()` function in a new cell.

    ```python
    <copy>
    query_orders()
    </copy>
    ```

    ![orders table after update](./images/task8.2.png " ")

    You can see that also in the relational `orders_demo` table, the total value has been updated.

3. Finally, let's create a new function that allows us to see both tables at once, i.e., we want to join `customers` and `orders` tables together. The function should also allow us to filter by the first name of the customer. Furthermore, the result should be nicely formatted in a table including column headers. We need to create a new cell with the following code:

    ```python
    <copy>
    import pandas as pd

    def query_customers_with_orders(first_name):
        with connection.cursor() as cursor:
            query = """
                SELECT *
                FROM customers_demo c
                JOIN orders_demo o ON c.id = o.customer_id
                WHERE c.first_name = :first_name
            """
            cursor.execute(query, {"first_name": first_name})
            rows = cursor.fetchall()
            column_names = [desc[0] for desc in cursor.description]
            df = pd.DataFrame(rows, columns=column_names)
            return df

    df = query_customers_with_orders("Dan")
    df.head() 
    </copy>
    ```

    ![join tables](./images/task8-last.png " ")

    As you can see we included some new features in our function. Let's have a closer look:

    ðŸ”´ **`import pandas as pd`** - This is a Python module that allows us to work with Pandas DataFrames. We will be using this module to format our output.

    ðŸ”´ **` column_names`** - This is a list of column names returned by our query which is a list of strings included in the cursor object returned by our query. 

    ðŸ”´ **`df.head()`** - This is a method that returns that returns the result of the query including the column names. 

## Conclusion

As a developer at Seer Holdings, you've just built the foundation for a GenAI-powered corporate approval system. We learned how to use Python and Oracle's Python driver `oracledb` to interact with Oracle AI Database's new features. You learned how to user the `cursor` object to execute SQL queries. Using the `cursor` object, you created a **JSON Duality View** and you even used some JSON functions to query documents using SQL syntax. Then, you also learned how to connect to the database using `pymongo` and retrieve data from a table in the database using **MongoDB syntax**. You created functions to update the **JSON Duality View** and you learned how these updates are also reflected in the underlying relational database tables.

This architecture eliminates the need for duplicating data across platforms and simplifies how developers build AI-ready applications. Whether you're calling SQL, working with JSON, or speaking Mongo, you're always working with a single source of truth inside the Oracle Database.

In the next lab, you'll build on this foundation to implement Retrieval-Augmented Generation (RAG), create vector embeddings, and generate personalized recommendations with Oracle AI Database and OCI Generative AI.

## Acknowledgements
* **Authors** - Linda Foinding
* **Contributors** - Francis Regalado, Kirk Kirkconnell
* **Last Updated By/Date** - Kirk Kirkconnell, February 2026
